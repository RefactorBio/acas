### Compound data operations start here
getAssayCompoundData <- function (filePath, plateData, testMode, tempFilePath, assayData, userBypassInventory, parameters, missingInstrumentFiles) {
  
  # If user selects userBypassInventory=TRUE in the GUI, this translates to Excel files being zipped together with standard instrument files
  # otherwise if userBypassInventory=FALSE, then proceed as usual (only instrument files zipped)
  # userBypassInventory is passed from higher-level function as an argument
  
  # If missingInstrumentFiles=TRUE (passed through the current function's argument) that means no .txt files were available (no instrument data) hence
  # instrumentData and consequently assayData are empty
  
  if (userBypassInventory) {
    # Table assayCompoundDT is generated by queries to the db to acquire the following: assayBarcode, cmpdBarcode, sourceType, plateType
    # Table assayCompoundDT is fed to the function below, formatCompoundData()
    # Replace formatCompoundData() by providing allCompounData directly with all info from the plate template without inventory
    
    # Measure number of (.txt) files expected, based on currently available plate barcodes passed through the assayData table
    # i.e. from the instrument data
    targetPlates <- unique(assayData$assayBarcode)
    numberOfPlates <- length(targetPlates)
    
    # Scenario where plate files (.xlsx) are zipped together with the instrument files (.txt), hence are parsed from the same uploaded zipped folder
    # All parsed files in /experiments/EXPT-000000XX/rawData/ passed through the current function's argument 'filepath'
    folderPathWithPlateFiles <- filePath
    allAvailableFiles <- list.files(folderPathWithPlateFiles)
    listOfPlateFiles <- allAvailableFiles[grep("\\.xlsx$", allAvailableFiles)]
    
    # Stop user if no (.xlsx) files were found in the folder with plate files
    if (length(listOfPlateFiles)==0) {
      stopUser("No plate files were detected in the uploaded zipped folder. Please check again zipped folder.")
    }
    
    # If missing instrument files, then bypass the following checks, since no .txt files were uploaded hence assayData is empty
    if (!missingInstrumentFiles) {
      # Check how many plates are loaded and compare that number with the available plates registered in assayData
      if (length(listOfPlateFiles) < numberOfPlates) {
        stopUser("The number of plates without inventory loaded is smaller than the number of plates for which instrument data are available")
      }
      if (length(listOfPlateFiles) > numberOfPlates) {
        stopUser("The number of plates without inventory loaded exceeds the number of plates for which instrument data are available")
      }
    }

        
#To-add: Check that all files have same number of tabs    
    
    # Initialize NULL datatables so they can be updated as the 'for' loop reads all available plate files immediately below
    allCompoundData <- c()
    microMolarFlag <- c()
    alternativeFilePlateAssociation <- c()
        
    for (currentExcelFile in listOfPlateFiles) {
      # Generate the filepath for each file stored in the folder
      plateFilePath <- file.path(folderPathWithPlateFiles, currentExcelFile)
      
      # Extract info from all tabs of the file from current plate
      allCompoundDataPlate <- getPlateContent(plateFilePath)
      
      # Check if concentration units are uM in current plate
      microMolarFlagPlate <- checkPlateConcentrationMicromolarUnits(allCompoundDataPlate)
      
      # Turn formatted dataframe form current plate to data table
      allCompoundDataPlate <- as.data.table(formatPlateContent(allCompoundDataPlate))
   
      # Isolate the plate barcode from the current plate
      currentPlateBarcode <- unique(allCompoundDataPlate$assayBarcode)
      # If there is plate barcode registered in the current file propmt the user
      if (length(currentPlateBarcode)==0 | currentPlateBarcode=="") {
        stopUser(paste0("No plate barcodes provided for file:", currentExcelFile))
      }
      # Create dataframe that associates plate barcode in current plate and the file it was derived from
      currentPlateAssociation <- data.frame(currentPlateBarcode, currentExcelFile, stringsAsFactors=FALSE)
      
      # Append plate barcodes and associated files one final dataframe
      alternativeFilePlateAssociation <- rbind(alternativeFilePlateAssociation, currentPlateAssociation)
      
      # Append datatables from all plates into one final datatable
      allCompoundData <- rbind(allCompoundData, allCompoundDataPlate)
      
      # Append flags showing that concentration units are uM from all plates into one final flag
      microMolarFlag <- rbind(microMolarFlag, microMolarFlagPlate)
    }
    
    # At this point allCompoundData includes -- besides the Data Reads -- the following headers:
    #cmpdBarcode, cmpdConc,  FlagWells, wellReference, assayBarcode,  corp_name, batch_number, plateType, sourceType, supplier
    
    standardHeaders <- c("cmpdBarcode",
                         "cmpdConc",
                         "FlagWells",
                         "wellReference",
                         "assayBarcode",
                         "corp_name",
                         "batch_number",
                         "plateType",
                         "sourceType",
                         "supplier")
    
    # Find what header names the Data Reads have and store in columnsWithDataReads that will be used later on
    indexOfNonDataReads <- colnames(allCompoundData) %in% standardHeaders
    columnsWithDataReads <- colnames(allCompoundData)[!indexOfNonDataReads]
    
    
    # If missing instrument files, then bypass the following checks, since no .txt files were uploaded hence assayData is empty
    if (!missingInstrumentFiles) {
      #    if (length(availableFiles) == numberOfPlates) {
      if (length(listOfPlateFiles) == numberOfPlates) {
        # If the number of plates match with what the number of plates found in the instrument data, make sure the plate barcodes match as well
        exactMatchForPlates <- all(unique(allCompoundData$assayBarcode) %in% targetPlates)
        if (!exactMatchForPlates) {
          stopUser("The barcodes for the plates without inventory registered in the system do not match the plate barcodes provided by the instrument")
        }
      } else {
        stopUser("The number of plates without inventory registered does not equal the number of plates for which instrument data are available")
      }
    }
        
    # Check the final flag showing if concentration units are uM from all plates
    if (all(microMolarFlag)) {
      # All plates read by the for-loop immediately above have micromolar concentrations
      microMolarFlag <- TRUE
    } else if (all(!microMolarFlag)) {
      # None of the plates read by the for-loop immediately above have micromolar concentrations
      microMolarFlag <- FALSE
    } else {
      stopUser("The concentration units recorded in the plates without inventory appear to be inconsistent from plate to plate. Please check the data.")
    }
    
    # Create an alternative instrumentData table that will be used in the case where instrument files (.txt) and plate association file (.csv) were
    # never uploaded through the zipped file

    # Create a data table that has only the necessary columns taken from allCompoundData and sort by assayBarcode
    colsAsNames <- c("assayBarcode", "wellReference", columnsWithDataReads)
    alternativeAssayData <- allCompoundData[, colsAsNames, with=FALSE]
    # Sort data table based on assayBarcode and reset row numbering
    alternativeAssayData <- alternativeAssayData[order(assayBarcode)]
    rownames(alternativeAssayData) <- NULL
    
    # Define the current order of plate barcodes and attach their order as a new column in the data table
    orderOfPlates <- unique(alternativeAssayData$assayBarcode)
    alternativeAssayData$plateOrder <- as.character(vapply(alternativeAssayData$assayBarcode, function(x) grep(x, orderOfPlates), 1))
    
    # Load necessary library to extract strings from wellReference
    library(stringr)
    # Extract letter part of wellReference (front of the string)
    alternativeAssayData$rowName <- paste0("-", str_extract(alternativeAssayData$wellReference, "^[A-Z]+"))
    # Extract number part of wellReference (back of the string)
    alternativeAssayData$colName <- as.numeric(str_extract(alternativeAssayData$wellReference, "[0-9]+$"))
    

    indexOfFiles <- as.numeric(vapply(alternativeAssayData$assayBarcode, function(x) grep(x, alternativeFilePlateAssociation$currentPlateBarcode), 1))
    alternativeAssayData$assayFileName <- alternativeFilePlateAssociation$currentExcelFile[indexOfFiles]

    # Extracting Read data
    readPosition <- c(1:length(columnsWithDataReads))
    dataTitle <- columnsWithDataReads
    readPositionDataReadCorrelation <- data.frame(readPosition, dataTitle, stringsAsFactors=FALSE)
    alternativePlateAssociationDT <- alternativeFilePlateAssociation[order(alternativeFilePlateAssociation$currentPlateBarcode),]
    alternativePlateAssociationDT <- as.data.table(merge(alternativePlateAssociationDT, readPositionDataReadCorrelation))
    
    # Rename the following columns and add new columns to match the expected format in table plateAssociationDT
    setnames(alternativePlateAssociationDT, old=c("currentPlateBarcode", "currentExcelFile"), new=c("assayBarcode", "assayFileName"))
    alternativePlateAssociationDT$compoundBarcode_1 <- NA
    alternativePlateAssociationDT$sidecarBarcode <- NA
    alternativePlateAssociationDT$instrumentType <- "no inventory"
    alternativePlateAssociationDT$plateOrder <- as.character(vapply(alternativePlateAssociationDT$assayBarcode, function(x) grep(x, orderOfPlates), 1))
    alternativePlateAssociationDT <- alternativePlateAssociationDT[order(assayBarcode)]
    
    # Create an alternative userInputReadTable -- to be RECTIFIED when new instrument is added?
    # The following commands construct the necessary arguments, directly borrowed from specificDataPreProcessor() which will be bypassed if no instrument files
    # are loaded
    readsTable <- getReadOrderTable(readList=parameters$primaryAnalysisReadList)
    matchNames <- parameters$matchReadName
    # Following command directly borrowed from getInstrumentSpecificData()
    alternativeUserInputReadTable <- formatUserInputActivityColumns(readsTable=readsTable, 
                                                                    activityColNames=unique(alternativePlateAssociationDT$dataTitle), 
                                                                    tempFilePath=tempFilePath, matchNames=matchNames)
    
    alternativeInstrumentData <- list(plateAssociationDT=alternativePlateAssociationDT, assayData=alternativeAssayData, userInputReadTable=alternativeUserInputReadTable)

  } else {
    # Execute commands as usual in this block (i.e. user did not include .xlsx files in the zipped folder which contains only .txt files and the .csv file)
    assayCompoundDT <- getPinTransfer(plateAssociationDT=plateData, testMode=testMode, tempFilePath=tempFilePath)
    
    allCompoundData <- formatCompoundData(assayCompoundDT, assayData, testMode=testMode, tempFilePath=tempFilePath)
  }

  
  # Table 'assayData' is passed to the current function as an argument to be used below, however in the case where instrument files are missing
  # then the assayData needs to be generated from alternativeInstrumentData
  if (missingInstrumentFiles) {
    assayData <- alternativeAssayData
  }
  
      
  # Check to make sure that wells don't have more than one compound listed
  overlappingPlate <- Filter(function(x) {length(unique(allCompoundData[assayBarcode == x, wellReference])) != 
                                                        length(allCompoundData[assayBarcode == x, wellReference])}, 
                             unique(allCompoundData[, assayBarcode]))
  if(length(overlappingPlate) > 0) {
    stopUser(paste0("Some sidecar and compound plates have overlapping wells.\n ",
                    "Please check the plates associated with the following assay barcode(s): ", 
                    paste(unlist(overlappingPlate), collapse=", ")))
  }
  
  setkeyv(allCompoundData, c("assayBarcode", "wellReference"))
  setkeyv(assayData, c("assayBarcode", "wellReference"))
  
  
  # If missing instrument files, then remove assayData the Data Reads columns before merging, to avoid duplicate Data Reads columns in the merged table
  if (!missingInstrumentFiles) {
    allAssayCompoundData <- merge(assayData, allCompoundData, all.x=TRUE)
  } else {
    assayData <- assayData[, !columnsWithDataReads, with=FALSE]
    allAssayCompoundData <- merge(assayData, allCompoundData, all.x=TRUE)
  }

  setkeyv(allAssayCompoundData, c("assayBarcode", "rowName", "wellReference"))
  
  allAssayCompoundData[ , assayFileName := NULL]
  
  colOrder <- c("plateType","assayBarcode","cmpdBarcode","sourceType","wellReference",
                "rowName","colName","corp_name","batch_number","cmpdConc","supplier","plateOrder")
  
  activityColumns <- setdiff(colnames(allAssayCompoundData), colOrder)
  setcolorder(allAssayCompoundData, c(colOrder, activityColumns))
  
  #setwd(normalizePath("../Analysis/"))
  write.table(allAssayCompoundData, file=file.path(tempFilePath, "output_well_data.srf"), append=FALSE, quote=FALSE, sep="\t", row.names=FALSE, col.names=TRUE, na="")
  
  # Needs to return a list for error catching
  # return(list(filePath=filePath, activity=allAssayCompoundData[ , activityColumns, with=FALSE]))
  
  if (userBypassInventory) {
    # If missing instrument files then return the alternative instrumentData table that would otherwise be vacant in higher-level functions, since no .txt instrument
    # files were uploaded
    if (missingInstrumentFiles) {
      return(list(filePath=filePath, allAssayCompoundData=allAssayCompoundData, activityColNames=activityColumns, microMolarFlag=microMolarFlag, alternativeInstrumentData=alternativeInstrumentData))
    } else {
      return(list(filePath=filePath, allAssayCompoundData=allAssayCompoundData, activityColNames=activityColumns, microMolarFlag=microMolarFlag))
    }
  } else {
    return(list(filePath=filePath, allAssayCompoundData=allAssayCompoundData, activityColNames=activityColumns))
  }
  
}